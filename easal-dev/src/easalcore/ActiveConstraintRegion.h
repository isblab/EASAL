/*
 This file is part of EASAL.

 EASAL is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 EASAL is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef ACTIVECONSTRAINTREGION_H_
#define ACTIVECONSTRAINTREGION_H_

#include <set>
#include <vector>
#include <unordered_map>

#include "CayleyPoint.h"
#include "MolecularUnit.h"

/**
 * This class is a holder for the set of feasible Cayley Points generated by
 * sampling and witness points coming from ancestor regions
 */
class ActiveConstraintRegion {
 public:
  /** @brief Default constructor */
  ActiveConstraintRegion();

  /** @brief Copy constructor */
  ActiveConstraintRegion(const ActiveConstraintRegion& acr);

  /** @brief Destructor */
  virtual ~ActiveConstraintRegion();

  /** @brief Cleans the region
   * Trim is used to prevent an ActiveConstraintRegion from taking up too much
   * memory after it is completed. this method is called every while after
   * saving some portion of points to the file.
   */
  void trim();

  /**
   * @bries Set the lower range and upper range values of parameters
   */
  void setSpaceVolume(double min[6], double max[6]);

  /**
   * @bries Get the lower range and upper range values of parameters
   */
  void getSpaceVolume(double min[6], double max[6]);

  /**
   * @return The compiled space of the contact graph with witness points first
   * and rest of the space afterwards.
   */
  std::vector<CayleyPoint*> getSpace();
  
  /**
   * @return List of Cayley points (Sample + Witness) sorted by 
   * the Cayley parameter value. Currently only works for 1-D nodes.
   */
  std::vector<CayleyPoint*> GetSortedSpace();
  
  /**
   * @return Index of a Cayley point (by id) in sorted_space_.
   */
  int GetIndexInSortedSpace(int cayley_point_id);


  CayleyPoint* GetCayleyPointFromID(int cayley_point_id); 

  /**
   * @brief Build the sorted_space_index_map_ data structure after the sorted_space_
   * has been created.
   */

  void buildSortedSpaceIndexMap();

  void setBoundaryPoint(int cpID, int flipNum, int nodeNum);

  /**
   * @return Vector of sample points.
   */
  std::vector<CayleyPoint*> GetSamplePoints() const;

  /**
   * @return The vector of feasible points (sample + witness).
   */
  std::vector<CayleyPoint*> getValidSpace() const;

  /**
   * @return The vector of witness points.
   */
  std::vector<CayleyPoint*> GetWitnessPoints() const;

  /**
   * @return The counts of the sampled points
   */
  int GetSamplePointsCount();

  /**
   * @return The count of the witness points
   */
  int GetWitnessPointsCount();

  /**
   * @return The size of the sampled union witness space
   */
  int GetSpaceSize();

  /**
   * @brief This adds a point to the sampled space.
   */
  void AddSamplePoint(CayleyPoint* point);

  /**
   * @brief This adds a point to the witness space.
   */
  void AddWitnessPoint(CayleyPoint* point);

  /** @brief A setter for witspace */
  void SetWitnessPoints(std::vector<CayleyPoint*> input);

  /** @brief A setter for space */
  void SetSamplePoints(std::vector<CayleyPoint*> input);

  /** @brief Returns the next valid sample point ID and increments
   *  samplePointsCreated.
   */
  int nextSamplePointID();
  
  /** @brief Returns the next valid witness point ID and increments
   *  witnessPointsCreated.
   */
  int nextWitnessPointID();

  int getSamplePointsCreated() const;
  int getWitnessPointsCreated() const;

  // int getPointsCreated(int) const;

  void setSamplePointsCreated(int);
  void setWitnessPointsCreated(int);

  CayleyPoint* getEntryPoint(int CayleyPointID);
  
  int FindFirstCayleyPointFromFlip(int flip); 

  /**
   * @brief Re-parametrize other region using this regions parameters.
   *
   * This function defines a vector of points with one orientation each
   * originating from another configuration space. The parameter values are
   * found from the orientations.
   */
  vector<CayleyPoint*> convertSpace(ActiveConstraintRegion* other,
                                    vector<pair<int, int> > paramlines,
                                    MolecularUnit* helA, MolecularUnit* helB);

  /** number of atoms in contact */
  static const int NO = 12;

 private:
  /** set of feasible witness Cayley Points achieved from ancestor */
  std::vector<CayleyPoint*> witness_points_;

  /** set of feasible (not necessarily "accepted" point i.e. there may be
   * collision or bad angle) Cayley Points but only accepted CayleyPoints have
   * an Orientation in it. actually we also keep non feasible (non realizable)
   * CayleyPoints in space as well in order to see blue boundary todo check if
   * tetrahedraequality is not used, do we save all blue points for display or
   * not save and just use volume variable
   * */
  std::vector<CayleyPoint*> sample_points_;

  /** Sorted cayley points */
  std::vector<CayleyPoint*> sorted_space_;

  /** A map to quickly look-up index of a Cayley point, by it's id, in 
   * sorted_space_.
   */
  std::unordered_map<int, int> sorted_space_index_map_;

  /**
   * For 6 parameters, holds the lower range and upper range values.
   * If there is less parameters then the range lower and upper are set to 0.
   */
  std::pair<double[6], double[6]>
      volume;  // todo check if this variable is needed!

  /** Count of sample Cayley points */
  int samplePointsCreated = 0;
  
  /** Count of witness Cayley points */
  int witnessPointsCreated = 0;
  
  // todo keep another variable to check if there is any green realization!

  // todo make set of space, witness points as a class called interior region,
  // boundary region respectively
};

#endif /* ACTIVECONSTRAINTREGION_H_ */
