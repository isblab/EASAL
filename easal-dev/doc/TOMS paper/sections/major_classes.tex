\subsection{Major Classes and Architecture of \texttt{EASAL}}
\label{sec:classes}

The core classes are AtlasBuilder, ActiveConstraintGraph, CayleyParameterization, ConvexChart, and CartesianRealizer.

\troy{Should the fundamental classes (such as MolecularUnit, Orientation, Atom, etc.\ be discussed? Or at least mentioned briefly as being basic and easy to understand.)}


\begin{enumerate}

%---------------------------------------------------------------------------------------------------------------
\item \textsf{Atlas} class: the directed acyclic graph that represent the relation of active constraint regions

\smallskip
Major Attributes:

\noindent --  \textsf{atlas}: set of AtlasNodes

\noindent --  \textsf{atlasRoot}: set of AtlasNodes that take place at the root of atlas.

\smallskip
Major Methods:\\
\smallskip
\noindent --  \textsf{search(node)}: depth first search the atlas from one of the node's ancestor to check whether the node exists in atlas or not. \\
It is used to avoid repeated sampling of the same region.
%During sampling when the boundary of the region is reached, it is necessary to check whether the boundary child region has been sampled before or not.
The time complexity of the search is $O(log(\text{depth of the tree})) = O( log(6) )$ considering we stop creating child nodes with overconstrained ActiveConstraintGraphs.\\


%---------------------------------------------------------------------------------------------------------------
\item \textsf{AtlasNode} class: node in the Atlas, each represents an active constraint region labeled by ActiveConstraintGraph.

\smallskip
Major Attributes:

\noindent --  \textsf{acg}: the active constraint graph of the node.\\
\noindent --  \textsf{region}: the set of Cayley points in the active region.\\
\noindent --  \textsf{connection}: the id of the child nodes in the atlas that represent the boundary of this node's region.\\



%---------------------------------------------------------------------------------------------------------------
\item \textsf{ActiveConstraintGraph} class: is used to store the set of active constraints and the corresponding vertices.

\smallskip
Major Attributes:

\noindent --  \textsf{activeConstraints}: set of \atom\ index pairs that represent contacts

\noindent --  \textsf{verticesA}: participating \atom\ indices from first \helix

\noindent --  \textsf{verticesB}: participating \atom\ indices from second \helix

\noindent --  \textsf{parameters}: set of \atom\ index pairs that represent parameters

\smallskip
Major Methods:\\
\smallskip
\noindent --  \textsf{completeTo3by3Graph()}: add \atom\ to make sure there are at least 3 \atom s from each \helix\ so that the graph is realizable.
While choosing additional atoms, it has 2 options, choosing the closest atom to each other or the atoms that leads certain angle. \\
\smallskip
\noindent --  \textsf{parameterMinDeviation()}: An alternative method to pick the parameters for $5$ dimensional region such that the range of each parameter has similar length.
It aims sampling more uniformly on Cartesian space by setting Cayley parameter space as spheric as possible.
%It is designed for dimension $5$, i.e., for ActiveConstraintGraph with only one active constraint. It adds extra 2 \atom s from each \helix\ and sets parameters that will yield spheric \chart. i.e. the range of each parameter has similar length. \\


%---------------------------------------------------------------------------------------------------------------
\item \textsf{ActiveConstraintRegion} class: the set of feasible Cayley Points generated by sampling

\smallskip
Major Attributes:

\noindent --  \textsf{space}: set of feasible Cayley Points

\noindent --  \textsf{witspace}: set of feasible witness Cayley Points achieved from ancestor

\smallskip
Major Methods:\\
\smallskip
\noindent --  \textsf{convertSpace(activeConstraintRegion)}: Re-parametrize another region using this regionâ€™s parameters.
%One orientation can be represented by different Cayley points according to different parametrization.
%This method converts each Cayley point of input activeConstraintRegion to the Cayley point parametrized by this region's parametrization. \\

%---------------------------------------------------------------------------------------------------------------
\item \textsf{CayleyPoint} class: a multi-dimension point in the Cayley parameter space, and the corresponding Cartesian space orientations of the \helix.

\smallskip
Major Attributes:

\noindent --  \textsf{data}: value of the Cayley parameters (non-edge length)\\
\noindent --  \textsf{orients}: set of Cartesian space Orientations of the \helix\ that, computed by realizing the active constraint graph with given length of edge/non-edges.\\

%We note that we use \emph{configuration} throughout to refer to
%a choice of Cayley parameters, typically distances between molecules,
%while the actual placement of the molcules with respect to one another
%in Cartesian $xyz$-space is called a \emph{realization}.
%---------------------------------------------------------------------------------------------------------------
\item \textsf{Orientation} class: the Euclidean transformation of \helix.
%Orientation stores only the necessary information to compute transformation matrix that will yield to Cartesian realization for the entire \helix\.

\smallskip
Major Attributes:

\noindent --  \textsf{FromB}: Cartesian coordinate of three \atom s from the \helix\ before the transformation.\\
\noindent --  \textsf{ToB}: Cartesian coordinate of three \atom s from the \helix\ after the transformation.\\
\noindent --  \textsf{connections}: the set of node indices that this orientation belongs. An orientation can take place in the boundary of multiple regions.\\

%---------------------------------------------------------------------------------------------------------------
\item \textsf{CayleyParameterization} class: choose non-edges in an ActiveConstraintGraph that complete the graph into 3-tree. Those non-edges are called the parameters.
The complexity of the sampling algorithm varies based on the choice of non-edges and the order in which they are fixed.
%should we move ordering parameters and related routines such as createTetrahedras, boundaryComputationWay and updateList to the convexchart class???

\smallskip
Major Attributes:

\noindent --  \textsf{partial3tree}: a flag to show whether ActiveConstraintGraph is partial 3-tree or not.

\noindent --  \textsf{parameters}: set of \atom\ pairs that represent non-edges

\noindent --  \textsf{tetra}: the ordered tetrahedra set that helps to define the order of parameters that will be important later during sampling procedure.
This data is later on passed to ConvexChart and CartesianRealizer to help their computations.

\noindent --  \textsf{updateList}: adjacency map for dependency of parameters. It provides the set of parameters whose range will be updated when one parameter fixed.

\noindent --  \textsf{boundaryComputationWay}:  inequalities that express the range of a parameter can be classified into either a linear or non-linear class.
This variable is characterization of the parameter that tells what inequality is needed to compute parameter range, i.e., triangular or tetrahedral inequality.

\smallskip
Major Methods:\\
\smallskip
\noindent --  \textsf{defineParameters()}:
The parameters $H$ of an active constraint graph are selected as maximal 3-realizable (3-tree) extension by leveraging the convex parametrization theory. % \cite{paper}.
It sets parameters retaining parent node's parameters as much as possible. So that we do not need to do much change on the parameter list as we dive into child regions.
For this purpose a look up table is created, that gives the parameters for a given constraints.\\
\smallskip
\noindent --  \textsf{createTetrahedras()}:
finds a 4 clique as a base tetrahedra. Then complete 3-tree is built up from a base tethedra by adding, at each step, a new vertex
edge-connected to the face of a tetrahedra. Store the tetrahedras in the order they are created in attribute \textsf{tetra}.\\
\smallskip
\noindent --  \textsf{orderParams()}: order of non-edges can guarantee efficient
sampling where finding bounds for each non-edge is either solving a linear inequality or
solving a single quadratic of one variable. \cite{ugandhar}
%the ordering of parameters is important to have exact convex chart while sampling. There is existing theories to solve it. However it was slow, so we have used our own heuristic way.

Here we use a simplified routine to order parameters with the following heuristics:\\
Fixing a non-edge, requires the range computation for the non-fixed parameter that takes place in same tetrahedra.
Lets D be a graph with vertices as parameters and edges representing if the two parameters takes place in the same tetrahedra.
Then which parameter should we choose as a root so that the depth of the graph D is minimum.
Here we aim the cascade of range computations to minimize.

In order to achieve this goal:\\
Order the parameters in the same order you built the tetrahedras. If there is one parameter in a tetrahedra, it is trivial, just add it to paramter list. Otherwise, prioritize the parameter which is shared by more tetrahedras, i.e., the vertex with max degrees.\\

%optimization


%---------------------------------------------------------------------------------------------------------------
\item \textsf{ConvexChart} class: is used to determine the \chart\ that parameterize the regions, i.e., it computes the range of parameters of ActiveConstraintGraph. \\
An exact convex chart yields feasible Cayley points for the current active constraint region.
The resulting Cayley configuration space is convex, before collisions or other (e.g.\ angle) constraints are introduced.
The range of parameters are computed by triangle and tetrahedra inequalities.

\smallskip
Major Attributes:

%\noindent --  \textsf{connections: fixed distance values of ActiveConstraintGraph such as active constraints or edges being taking place in one helix.
\noindent --  \textsf{maxconnections}: upper bound of the parameters' range

\noindent --  \textsf{minconnections}: lower bound of the parameters' range

\noindent --  \textsf{paramconnections}: current value of parameters

\smallskip
Major Methods:\\
\smallskip
\noindent --  \textsf{initializeChart()}: it initalizes the boundaries of convex chart.
Tighter bounds are given in \cite{ugandhar}.\\

\smallskip
\noindent --  \textsf{computeRange(v1, v2)}: computes the range of the parameter v1-v2 in order to eliminate sampling infeasible grid points.\\
Range computation is required in every iteration for dependent parameters.
When there is one parameter in a tetrahedra, the range of parameter can be computed through tetrahedral inequalities.
If there are 2 unfixed parameters at the moment in a tetrahedra, then the range of one of the parameters will be computed through triangular inequalities and fixed. And the range of other parameter will be computed through tetrahedral inequalities. The range computation way depends on the order of parameters. \\
\smallskip
\noindent --  \textsf{setMinMaxByTriangleInequalityParam(v1, v2)}: computes the range of the non-edge v1-v2 through triangular inequalities. uses all triangles that this edge is shared.\\
\smallskip
\noindent --  \textsf{setMinMaxByTetraHedraInequality(v1, v2, tetraHedra)}: computes the range of the non-edge v1-v2 through tetrahedral inequality using input tetrahedra\\
\smallskip
\noindent --  \textsf{stepGrid}: sets parameter point to the next grid point within the computed range.\\
%Range computation is required in every iteration for dependent parameters.
%Triangular inequality and tetrahedral equality is used to find boundary hence eliminate sampling infeasible grid points.\\

%stepGrid: after stepping on pth parameter, it should update min max range for params from 0th till p'th  not just p'th parameter because if p'th parameters value is changed then that means every previous parameters feasible range will change.
\smallskip
\noindent --  \textsf{stepNeighbour()}: sets parameter point to the neighbour grid point in all dimensions consecutively.\\
\smallskip
\noindent --  \textsf{stepGridBinary()}: sets parameter point to the somewhere between current point and neighbour grid point according to binary search procedure in boundaryDetection.\\


%---------------------------------------------------------------------------------------------------------------
\item \textsf{CartesianRealizer} class: %(?naming CartesianOrientatior)
contains routines that computes Orientation that represents transformations of the rigid \helix\ s relative to each other.
It computes Cartesian realization of an ACG with the parameter lengths taken from cayleyPoint and active constraint lengths for a specific flip.
It intentionally ignores the remainder of the assembly constraint system, namely atom markers not in G and their constraints.

\smallskip
Major Attributes:

\noindent --  \textsf{positions}: Cartesian coordinates of vertices in ActiveConstraintGraph

\noindent --  \textsf{pconnections}: contains all fixed distances plus current distance values of non-edges of ActiveConstraintGraph

\smallskip
Major Methods:\\
\smallskip
%actually no need for whole convexChart, what you need is cayleyPoint to achieve current paramValues, and fixed distances of inter/intra molecule
\noindent --  \textsf{computeRealization(activeConstraintGraph, convexChart, flipno)}: computes the Orientation by leveraging partial 3-tree techniques.
activeConstraintGraph which is a complete 3-tree is built up from a base tethedra by adding, at each step, a new vertex
edge-connected to the face of a tetrahedra.\\
\smallskip
\noindent --  \textsf{setmybase(tetrahedra)}:  finds Cartesian coordinates of the vertices of tetrahedra by known edge lengths \\
\smallskip
\noindent --  \textsf{findLocation(vertex, face)}: finds Cartesian coordinates of the vertex that is connected to the face of a tetrahedra\\
%\noindent --  \textsf{findLengthsAcordingToTwoKnownPoints(vertex): sets the distance of any undefined edge connected to vertex. (actually you may put this in the above method, if not worth to talk)

%---------------------------------------------------------------------------------------------------------------
\item \textsf{ConstraintCheck} class: is designed to check whether any non-active constraints become active or whether they are violated.

User have the option to define set of constraints of interest. In that case, new constraint activation check will be done only for this set.
For an input Orientation, ConstraintCheck first computes the Cartesian realization for the entire \helix\ then passes it to the subroutines to do user specified constraint check such as steric constraints, tethering constraints or angle constraints.\\


%---------------------------------------------------------------------------------------------------------------
\item \textsf{AtlasBuilder} class: populates the ActiveConstraintRegion for each activeConstraintGraph by sampling inside the boundaries of its ConvexChart.
It creates and explores only regions that contain at least one Cartesian realization, witness point.
If activeConstraintGraph is not partial 3-tree, then the region is populated by ray tracing, i.e., witness points coming from all ancestors.


\begin{comment}
AtlasBuilder currently follows predefined direction to walk through on sampling space.
It can be modified to have a recursive sampling so that wastefully sampling the body of the violated region will be  eliminated.
Since recursive sampling can identify the boundary of the violated region by sampling from all directions.
%
Also again recursive sampling can identify the boundary of feasible region hence would eliminate boundary computation in every step. :)
(Actually even in predefined direction sampling, you do not need to compute boundaries, just keep sampling, if you hit a neg volume then stop sampling in that direction.! )
(No, you may jump to an infeasible region and stuck there, it should always start sampling withing feasible region computed by chart.)
\end{comment}

\smallskip
Major Attributes:

\noindent --  \textsf{positions}: Cartesian coordinates of vertices in ActiveConstraintGraph

\smallskip
Major Methods:\\
\smallskip
\noindent --  \textsf{startAtlas()}: for each (bi)tether creates root atlasNode labeled with a contact graph $G_F$ where $F$ is the (bi)Tether, i.e., $1$ (or $2$) specific contacts. Then calls sampleExplore for that atlasNode.\\
\smallskip
\noindent --  \textsf{sampleExplore(atlasNode)}: elaborated in Section \ref{sec:sampleExplore}.\\
\smallskip
\noindent --  \textsf{determineStepSizeDynamically()}: finds out \stp\ by given \tns, total number of samples. Each 5d-atlas node has its own \stp\ computed by volume of Cayley parameter space of the node over total number of samples per node. The number of samples per node roughly can be computed by \tns\ over total number of root(starter) atlas nodes, \m. The number of samples in child nodes are ignorable since the volume of regions in low dimensional nodes are ignorable compared to the regions of high dimensional nodes. \\
%To be more specific, the number of samples distribution over nodes would be proportional with the sum of radius of the tether of the node.
%need explanation how the cayley volume is computed, i just stepped on ot without realizing within the chart. since no realization it is fast. but since chart boundary is computed in most of the steps, kind of slow.
\smallskip
\noindent --  \textsf{boundaryDetection()}: elaborated in Section \ref{sec:boundaryDetection}.\\
\smallskip
\noindent --  \textsf{rayTracing()}:
a recursive routine to explore regions that do not have an active constraint graph that is a partial 3-tree, by inheriting samples from
the parent node(s).\\


%---------------------------------------------------------------------------------------------------------------
\end{enumerate}


